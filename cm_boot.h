/*
	cm_boot.h - Cortex-M core boot util
	gbm 10'2024..12'2025
*/

/* The file should be included after MCU-specific header, so that Cortex-M core registers are defined.
 *
 * For STM32, BOOT_ADDR should be defined to be equal to system ROM base for a specific MCU model,
 * as specified in AN2606 document.
 * All the (pseudo)functions defined here should be called from the main thread code, NOT form ISRs.
 * Check the assembly code (.list file) generated by the compiler for calling app's ResetHandler;
 * it will not work if SP register is used after __set_MSP.
 * With gcc-12, the correct code is produced with -O1 and above while -O0 and -Os use SP (wrong).
 * With gcc-14, use anything other than -O0.
 *
 * In the application's link script, change the FLASH starting address to skip the space used by the bootloader;
 * a convenient way to achieve this is to add symbol definition before the MEMORY block (0x4000 is an example app offset value):

   _flash_offset = 0x4000;

 * and to modify the FLASH definition in MEMORY block
 * (the original LENGTH value should be preserved - 128K is an example value)

     FLASH    (rx)    : ORIGIN = 0x08000000 + _flash_offset,   LENGTH = 128K - _flash_offset

 * The exception vector table may be setup by a bootloader or by an application.
 * To do the setup in the app, define VECTABLE_SETUP_BY_APP symbol
 * before including this file in the application and the bootloader.
 * Different linker script setup is required for these two cases - read the relevant comments below.
 */

#ifndef CM_BOOT_H_
#define CM_BOOT_H_

#ifdef __CORTEX_M
/*
 * Optional boot flag at the start of RAM; if used:
 * - must be defined in the bootloader AND the app as
 *
   __attribute__((section(".ram_boot_flag"))) volatile uint32_t boot_flag;

 * - .ram_boot_flag input section definition must be added to the linker scripts, as described below
 *
 * (Placing the boot flag at the start of RAM rather that at the end makes the binary code portable
 * between similar MCUs with different RAM sizes.)
 */
extern volatile uint32_t boot_flag;

/*
 * Utility functions for disabling interrupt sources. With a proper arrangement,
 * when starting the app and the bootloader in a clean environment right out of MCU reset,
 * these should not be needed.
 */
#define NELEMSOF(a)	(sizeof (a) / sizeof ((a)[0]))

static inline void disable_all_ints(void)
{
	SysTick->CTRL = 0;
	for (uint8_t i = 0; i < NELEMSOF(NVIC->ICER); i++)
		NVIC->ICER[i] = 0;
}

// ICTR values F401:2

static inline void disable_unpend_all_ints(void)
{
	SysTick->CTRL = 0;
	SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk | SCB_ICSR_PENDSVCLR_Msk;

	for (uint8_t i = 0; i < NELEMSOF(NVIC->ICER); i++)
	{
		NVIC->ICER[i] = 0;
		NVIC->ICPR[i] = 0;
	}
}

// minimal structure for starting code image from arbitrary address
struct cm_init_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
};

#if __CORTEX_M > 1

// ensure that __VTOR_PRESENT symbol is defined for Cortex-M cores supporting VTOR
#ifndef __VTOR_PRESENT
// the symbol may or may not be defined in core header, so define it here
#define __VTOR_PRESENT	1u
#endif

// if the size of vector table declared below is needed by the application,
// define NVIC_IRQs before including this header
#ifndef NVIC_IRQs
#define NVIC_IRQs
#endif

// General Cortex-M vector table with variable no. of IRQ vectors
struct cm_vectable_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
	void (*NMI_Handler)(void);
	void (*HardFault_Handler)(void);
	void (*MemManage_Handler)(void);	// v7
	void (*BusFault_Handler)(void);		// v7
	void (*UsageFault_Handler)(void);	// v7
	void (*SecureFault_Handler)(void);	// v8
	void (*Exc8_Handler)(void);
	void (*Exc9_Handler)(void);
	void (*Exc10_Handler)(void);
	void (*SVC_Handler)(void);
	void (*DebugMon_Handler)(void);	// v7
	void (*Exc13_Handler)(void);
	void (*PendSV_Handler)(void);
	void (*SysTick_Handler)(void);
    void (*NVIC_Interrupt[NVIC_IRQs])(void);
};

extern struct cm_vectable_ g_pfnVectors;	// defined in startup module

#else	// Cortex-M0 -> 32 NVIC interrupts available
// if less than 32 NVIC interrupts are implemented and used in the application,
// you may define NVIC_IRQs before including this header for a small saving on RAM
#ifndef NVIC_IRQs
#define NVIC_IRQs	32
#endif

// Cortex-M0, M0+ vector table with 32 IRQ vectors
struct cm0_vectable_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
	void (*NMI_Handler)(void);
	void (*HardFault_Handler)(void);
	uint32_t unused4[7];
	void (*SVC_Handler)(void);	// 11
	uint32_t unused12[2];
	void (*PendSV_Handler)(void);
	void (*SysTick_Handler)(void);
    void (*NVIC_Interrupt[NVIC_IRQs])(void);
};

extern struct cm0_vectable_ g_pfnVectors;	// vector table in Flash, defined in startup module
extern struct cm0_vectable_ ram_vectable;	// usually needed if VTOR register not present
#endif

#ifdef __VTOR_PRESENT

#ifdef VECTABLE_SETUP_BY_APP

// If VTOR is present, call this function at the very start of application's main() function.
// This will fix the possibly incorrect setting contained in SystemInit().
static inline void vectable_setup_by_app(void)
{
	SCB->VTOR = &g_pfnVectors;
}

#else	// vector table setup by bootloader

static inline void vectable_setup(uint32_t addr)
{
	// at this point all interrupts must be disabled (NVIC, SysTick)
	SCB->VTOR = addr;
}

#endif // VECTABLE_SETUP_BY_APP

#else	// VTOR register not present (STM32F0 series)
/*
 * Vector table setup done by the bootloader for MCUs without VTOR:
 *
 * 1. Put the definition of ram_vectable in a .c source file of the bootloader AND the application:

	  __attribute__((section(".ram_isr_vector"))) struct cm0_vectable_ ram_vectable;

	  (The definition in the bootloader is needed only for ensuring the proper placement of boot_flag in RAM.)

 * 2. Modify the bootloader's and application's linker script:
 *  - put the following output section definition BEFORE _sidata symbol definition preceding the .data section:
 *
	  .ram_start_noinit (NOLOAD):
	  {
		KEEP(*(.ram_isr_vector))
		KEEP(*(.ram_boot_flag))
	  } >RAM
 *
 */

#ifdef VECTABLE_SETUP_BY_APP

static inline void vectable_setup_by_app(void)
{
	ram_vectable = g_pfnVectors;	// copy vectors from Flash to the start of RAM
}

#else	// vector table setup by bootloader

static inline void vectable_setup(uint32_t addr)
{
	ram_vectable = *(const struct cm0_vectable_ *)addr;	// copy vectors from Flash to the start of RAM
}

#endif // VECTABLE_SETUP_BY_APP

#endif // __VTOR_PRESENT


// Set Stack Pointer and start ResetHandler - may be used for starting any code, including the built-in vendor bootloader
static inline void app_start(uint32_t addr)
{
#ifdef STM32F0	// F0 only - set memory mapping for vectable access
	if (addr != FLASH_BASE)	// bootloader will only start after reset, no need to set main Flash mapping
	{
		RCC->APB2ENR = RCC_APB2ENR_SYSCFGCOMPEN;
		SYSCFG->CFGR1 = addr == BOOT_ADDR ? SYSCFG_CFGR1_MEM_SYS : SYSCFG_CFGR1_MEM_RAM;
	}
#endif
	// at this point all interrupt sources must be disabled (NVIC, SysTick) and the CPU must have interrupts enabled
	const struct cm_init_ *app_init = (const struct cm_init_ *) addr;
	__set_MSP(app_init->Init_SP);
	// SP register should not be used in the assembly instructions implementing the statement below
	// - do NOT use -O0, check the .list file to verify.
	app_init->Reset_Handler();
//	for (;;) ;
}

// 2-in-1 for starting any code from the bootloader
static inline void app_invoke(uint32_t addr)
{
#ifndef VECTABLE_SETUP_BY_APP
	vectable_setup(addr);
#endif
	app_start(addr);
}

#else	// __CORTEX_M symbol not defined
#error MCU header file must be included before cm_boot.h
#endif

#endif	// CM_BOOT_H_
