/*
	cm_boot.h - Cortex-M core boot util
	gbm 10'2024..12'2025
*/

/* The file should be included after MCU-specific header, so that Cortex-M core registers are defined.
 * All the (pseudo)functions defined here should be called from the main thread code, NOT form ISRs.
 * Check the assembly code (.list file) generated by the compiler for calling app reset handler;
 * it will not work if SP register is used after __set_MSP.
 * For gcc12, the correct code is produced with -O1 and above while -O0 and -Os use SP (wrong).
 * In the application's link script, change the FLASH starting address to skip the space used by the bootloader.
 */

#ifndef CM_BOOT_H_
#define CM_BOOT_H_

#ifdef __CORTEX_M

#define NELEMSOF(a)	(sizeof (a) / sizeof ((a)[0]))

static inline void disable_all_ints(void)
{
	SysTick->CTRL = 0;
	for (uint8_t i = 0; i < NELEMSOF(NVIC->ICER); i++)
		NVIC->ICER[i] = 0;
}

// ICTR values F401:2

static inline void disable_unpend_all_ints(void)
{
	SysTick->CTRL = 0;
	SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk | SCB_ICSR_PENDSVCLR_Msk;

	for (uint8_t i = 0; i < NELEMSOF(NVIC->ICER); i++)
	{
		NVIC->ICER[i] = 0;
		NVIC->ICPR[i] = 0;
	}
}

// minimal structure for starting code image from arbitrary address
struct cm_init_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
};

#if __CORTEX_M > 1
#ifndef __VTOR_PRESENT
// the symbol may or may not be defined in core header, so define it here
#define __VTOR_PRESENT	1u
#endif
// if the size of vector table below is needed by the application,
// define NVIC_IRQs before including this header
#ifndef NVIC_IRQs
#define NVIC_IRQs
#endif

// General Cortex-M vector table with variable no. of IRQ vectors
struct cm_vectable_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
	void (*NMI_Handler)(void);
	void (*HardFault_Handler)(void);
	void (*MemManage_Handler)(void);	// v7
	void (*BusFault_Handler)(void);		// v7
	void (*UsageFault_Handler)(void);	// v7
	void (*SecureFault_Handler)(void);	// v8
	void (*Exc8_Handler)(void);
	void (*Exc9_Handler)(void);
	void (*Exc10_Handler)(void);
	void (*SVC_Handler)(void);
	void (*DebugMon_Handler)(void);	// v7
	void (*Exc13_Handler)(void);
	void (*PendSV_Handler)(void);
	void (*SysTick_Handler)(void);
    void (*NVIC_Interrupt[NVIC_IRQs])(void);
};

extern struct cm_vectable_ g_pfnVectors;

#else	// Cortex-M0 -> 32 NVIC interrupts available
// if less than 32 NVIC interrupts are implemented and used in the application,
// you may define NVIC_IRQs before including this header for a small saving on RAM
#ifndef NVIC_IRQs
#define NVIC_IRQs	32
#endif

// Cortex-M0, M0+ vector table with 32 IRQ vectors
struct cm0_vectable_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
	void (*NMI_Handler)(void);
	void (*HardFault_Handler)(void);
	uint32_t unused4[7];
	void (*SVC_Handler)(void);
	uint32_t unused12[2];
	void (*PendSV_Handler)(void);
	void (*SysTick_Handler)(void);
    void (*NVIC_Interrupt[NVIC_IRQs])(void);
};

extern struct cm0_vectable_ g_pfnVectors;
#endif

static inline void vectable_setup(uint32_t addr)
{
	// at this point all interrupts must be disabled (NVIC, SysTick)
#ifdef __VTOR_PRESENT
	SCB->VTOR = addr;
#else	// Cortex-M0
	/* Put the definition of ram_vectable in some .c source file of the bootloader AND the application:
	    __attribute__((section(".ram_isr_vector"))) struct cm0_vectable_ ram_vectable;
	 *
	 * In the bootloader's and application's linker script files, put the following section def BEFORE .data section:
	    .ram_isr_vector (NOLOAD):
        {
            KEEP(*(.ram_isr_vector))
        } >RAM
	 */
	extern struct cm0_vectable_ ram_vectable;
	ram_vectable = *(const struct cm0_vectable_ *)addr;	// copy vectors to start of RAM
#ifdef STM32F0	// added 04.12.2025
	SYSCFG->CFGR1 = SYSCFG_CFGR1_MEM_RAM;	// map RAM at 0
#endif
#endif
}

// Set Stack Pointer and start ResetHandler - may be used for starting any code, including the built-in vendor bootloader
static inline void app_start(uint32_t addr)
{
	// at this point all interrupt sources must be disabled (NVIC, SysTick) and the CPU must have interrupts enabled
	const struct cm_init_ *app_init = (const struct cm_init_ *) addr;
	__set_MSP(app_init->Init_SP);
	// SP register should not be used in the assembly instructions implementing the statement below
	// - check the .list file to verify that.
	app_init->Reset_Handler();
}

// 2-in-1 for starting any user code - app or bootloder
static inline void app_invoke(uint32_t addr)
{
	vectable_setup(addr);
	app_start(addr);
}

#else
#error MCU header file must be included before cm_boot.h
#endif

#endif	// CM_BOOT_H_
