/*
	Cortex-M core boot util
	gbm 10'2024
*/

/* The file should be included after MCU-specific header, so that Cortex-M core registers are defined.
 *
 * Check the assembly code (.list file) generated by the compiler for calling app reset handler;
 * it will nor work if SP register is used after __set_MSP.
 * For gcc12, the correct code is produced with -O1 and above while -O0 and -Os use SP (wrong).
 */

#ifndef CM_BOOT_H_
#define CM_BOOT_H_

#ifdef __CORTEX_M

#define NELEMSOF(a)	(sizeof (a) / sizeof ((a)[0]))

static inline void disable_all_ints(void)
{
	SysTick->CTRL = 0;
	for (uint8_t i = 0; i < NELEMSOF(NVIC->ICER); i++)
		NVIC->ICER[i] = 0;
}

// ICTR values F401:2

static inline void disable_unpend_all_ints(void)
{
	SysTick->CTRL = 0;
	SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk | SCB_ICSR_PENDSVCLR_Msk;

	for (uint8_t i = 0; i < NELEMSOF(NVIC->ICER); i++)
	{
		NVIC->ICER[i] = 0;
		NVIC->ICPR[i] = 0;
	}
}

// minimal structure for starting code image from arbitrary address
struct cm_init_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
};

#if __CORTEX_M > 1
// if the size of vector table is needed by the application,
// define NVIC_IRQs before including this header
#ifndef NVIC_IRQs
#define NVIC_IRQs
#endif

// General Cortex-M vector table with variable no. of IRQ vectors
struct cm_vectable_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
	void (*NMI_Handler)(void);
	void (*HardFault_Handler)(void);
	void (*MemManage_Handler)(void);	// v7
	void (*BusFault_Handler)(void);		// v7
	void (*UsageFault_Handler)(void);	// v7
	void (*SecureFault_Handler)(void);	// v8
	void (*Exc8_Handler)(void);
	void (*Exc9_Handler)(void);
	void (*Exc10_Handler)(void);
	void (*SVC_Handler)(void);
	void (*DebugMon_Handler)(void);	// v7
	void (*Exc13_Handler)(void);
	void (*PendSV_Handler)(void);
	void (*SysTick_Handler)(void);
    void (*NVIC_Interrupt[NVIC_IRQs])(void);
};

extern struct cm_vectable_ g_pfnVectors;

#else	// Cortex-M0 -> 32 NVIC interrupts available
// if less than 32 NVIC interrupts are implemented and used in the application,
// you may define NVIC_IRQs before including this header for a small saving on RAM
#ifndef NVIC_IRQs
#define NVIC_IRQs	32
#endif

// Cortex-M0, M0+ vector table with 32 IRQ vectors
struct cm0_vectable_ {
	uint32_t Init_SP;
	void (*Reset_Handler)(void);
	void (*NMI_Handler)(void);
	void (*HardFault_Handler)(void);
	uint32_t unused4[7];
	void (*SVC_Handler)(void);
	uint32_t unused12[2];
	void (*PendSV_Handler)(void);
	void (*SysTick_Handler)(void);
    void (*NVIC_Interrupt[NVIC_IRQs])(void);
};

extern struct cm0_vectable_ g_pfnVectors;
#endif

static inline void vectable_setup(uint32_t addr)
{
	// at this point all interrupts must be disabled (NVIC, SysTick)
#ifdef __VTOR_PRESENT
	SCB->VTOR = addr;
#else	// Cortex-M0
	// define with __attribute__((section(".ram_isr_vector")))
	extern struct cm0_vectable_ ram_vectable;
	ram_vectable = *(const struct cm0_vectable_ *)addr;	// copy vectors to start of RAM
#endif
}

static inline void app_start(uint32_t addr)
{
	// at this point all interrupts must be disabled (NVIC, SysTick)
	const struct cm_init_ *app_init = (const struct cm_init_ *) addr;
	__set_MSP(app_init->Init_SP);
	// SP register should not be used in the assembly instructions implementing the statement below
	app_init->Reset_Handler();
}

#else
#error MCU header file must be included before cm_boot.h
#endif

#endif	// CM_BOOT_H_
